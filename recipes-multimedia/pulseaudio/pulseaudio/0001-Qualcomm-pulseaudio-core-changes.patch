From 4ac27aedd627461b76e97e21ca25bcc591a45d05 Mon Sep 17 00:00:00 2001
From: Manikantan R <quic_manrav@quicinc.com>
Date: Tue, 30 Apr 2024 17:50:45 +0530
Subject: [PATCH] [PATCH] Qualcomm changes on PA core

Signed-off-by: Manikantan R <quic_manrav@quicinc.com>
---
 src/modules/alsa/90-pulseaudio.rules          |   2 +
 src/modules/alsa/alsa-sink.c                  |   2 +-
 src/modules/meson.build                       |   2 +
 src/modules/module-pipe-source.c              |  55 +++
 src/modules/module-role-exclusive.c           | 252 ++++++++++++++
 src/modules/module-role-ignore.c              | 327 ++++++++++++++++++
 src/modules/module-switch-on-port-available.c |  68 +++-
 src/pulse/channelmap.c                        |  21 ++
 src/pulse/def.h                               |   3 +
 src/pulse/format.c                            |  48 +++
 src/pulse/format.h                            |  43 +++
 src/pulse/map-file                            |   2 +
 src/pulse/meson.build                         |   2 +-
 src/pulse/stream.c                            |   9 +
 src/pulsecore/core-format.c                   |  25 +-
 src/pulsecore/device-port.c                   |  10 +-
 src/pulsecore/memchunk.h                      |   1 +
 src/pulsecore/meson.build                     |  47 +--
 src/pulsecore/protocol-native.c               |  76 +++-
 src/pulsecore/sink-input.c                    |  98 +++++-
 src/pulsecore/sink-input.h                    |  12 +
 src/pulsecore/sink.c                          | 101 +++++-
 src/pulsecore/sink.h                          |  35 +-
 src/pulsecore/source-output.c                 |  24 +-
 src/pulsecore/source-output.h                 |   1 +
 src/pulsecore/source.c                        |   7 +-
 src/utils/pacat.c                             |  87 ++++-
 27 files changed, 1257 insertions(+), 103 deletions(-)
 create mode 100644 src/modules/module-role-exclusive.c
 create mode 100644 src/modules/module-role-ignore.c

diff --git a/src/modules/alsa/90-pulseaudio.rules b/src/modules/alsa/90-pulseaudio.rules
index cf6ad9c..7c098d9 100644
--- a/src/modules/alsa/90-pulseaudio.rules
+++ b/src/modules/alsa/90-pulseaudio.rules
@@ -15,6 +15,8 @@
 # You should have received a copy of the GNU Lesser General Public License
 # along with PulseAudio; if not, see <http://www.gnu.org/licenses/>.
 
+DEVPATH=="/devices/platform/soc/soc:spf_core_platform/soc:spf_core_platform:sound/sound/card*", ENV{PULSE_IGNORE}="1"
+
 SUBSYSTEM!="sound", GOTO="pulseaudio_end"
 ACTION!="change", GOTO="pulseaudio_end"
 KERNEL!="card*", GOTO="pulseaudio_end"
diff --git a/src/modules/alsa/alsa-sink.c b/src/modules/alsa/alsa-sink.c
index 76a710e..0d23722 100644
--- a/src/modules/alsa/alsa-sink.c
+++ b/src/modules/alsa/alsa-sink.c
@@ -1164,7 +1164,7 @@ static int unsuspend(struct userdata *u, bool recovering) {
 
     pa_log_info("Trying resume...");
 
-    if ((is_iec958(u) || is_hdmi(u)) && pa_sink_is_passthrough(u->sink)) {
+    if ((is_iec958(u) || is_hdmi(u)) && pa_sink_is_exclusive(u->sink)) {
         /* Need to open device in NONAUDIO mode */
         int len = strlen(u->device_name) + 8;
 
diff --git a/src/modules/meson.build b/src/modules/meson.build
index be72c3b..7770a87 100644
--- a/src/modules/meson.build
+++ b/src/modules/meson.build
@@ -45,6 +45,8 @@ all_modules = [
   [ 'module-rescue-streams', 'module-rescue-streams.c' ],
   [ 'module-role-cork', ['module-role-cork.c', 'stream-interaction.c'], 'stream-interaction.h' ],
   [ 'module-role-ducking', ['module-role-ducking.c', 'stream-interaction.c'], 'stream-interaction.h' ],
+  [ 'module-role-ignore', 'module-role-ignore.c' ],
+  [ 'module-role-exclusive', 'module-role-exclusive.c' ],
   [ 'module-simple-protocol-tcp', 'module-protocol-stub.c', [], ['-DUSE_PROTOCOL_SIMPLE', '-DUSE_TCP_SOCKETS'], [], libprotocol_simple ],
   [ 'module-simple-protocol-unix', 'module-protocol-stub.c', [], ['-DUSE_PROTOCOL_SIMPLE', '-DUSE_UNIX_SOCKETS'], [], libprotocol_simple ],
   [ 'module-sine', 'module-sine.c' ],
diff --git a/src/modules/module-pipe-source.c b/src/modules/module-pipe-source.c
index 32b35c1..7c08018 100644
--- a/src/modules/module-pipe-source.c
+++ b/src/modules/module-pipe-source.c
@@ -55,6 +55,7 @@ PA_MODULE_USAGE(
         "source_properties=<properties for the source> "
         "file=<path of the FIFO> "
         "format=<sample format> "
+        "formats=<semi-colon separated source formats> "
         "rate=<sample rate> "
         "channels=<number of channels> "
         "channel_map=<channel map>");
@@ -67,6 +68,9 @@ struct userdata {
     pa_module *module;
     pa_source *source;
 
+    pa_idxset *formats;
+    bool compressed;
+
     pa_thread *thread;
     pa_thread_mq thread_mq;
     pa_rtpoll *rtpoll;
@@ -84,6 +88,7 @@ static const char* const valid_modargs[] = {
     "source_properties",
     "file",
     "format",
+    "formats",
     "rate",
     "channels",
     "channel_map",
@@ -202,6 +207,14 @@ finish:
     pa_log_debug("Thread shutting down");
 }
 
+static pa_idxset* source_get_formats(pa_source *s) {
+    struct userdata *u = s->userdata;
+
+    pa_assert(u);
+
+    return pa_idxset_copy(u->formats, (pa_copy_func_t)pa_format_info_copy);
+}
+
 int pa__init(pa_module *m) {
     struct userdata *u;
     struct stat st;
@@ -210,6 +223,8 @@ int pa__init(pa_module *m) {
     pa_modargs *ma;
     struct pollfd *pollfd;
     pa_source_new_data data;
+    pa_format_info *format;
+    const char *formats;
 
     pa_assert(m);
 
@@ -265,6 +280,43 @@ int pa__init(pa_module *m) {
         goto fail;
     }
 
+    // Added list of supported formats by the source
+    u->formats = pa_idxset_new(NULL, NULL);
+    if ((formats = pa_modargs_get_value(ma, "formats", NULL))) {
+        char *f = NULL;
+        const char *state = NULL;
+
+        while ((f = pa_split(formats, ";", &state))) {
+            format = pa_format_info_from_string(pa_strip(f));
+
+            if (!format) {
+                pa_log(_("Failed to set format: invalid format string %s"), f);
+                goto fail;
+            }
+
+            /* Let's minimise the number of ways to provide configuration */
+            if (pa_format_info_is_pcm(format)) {
+                pa_log(_("The 'formats' argument should only be used for compressed formats"));
+                goto fail;
+            }
+
+            pa_idxset_put(u->formats, format, NULL);
+        }
+
+        u->compressed = true;
+
+        /* Set ourselves up for a 1 byte-per-frame sample spec */
+        ss.format = PA_SAMPLE_U8;
+        ss.channels = 1;
+        pa_channel_map_init_mono(&map);
+
+    } else {
+        format = pa_format_info_new();
+        format->encoding = PA_ENCODING_PCM;
+        pa_idxset_put(u->formats, format, NULL);
+        u->compressed = false;
+    }
+
     pa_source_new_data_init(&data);
     data.driver = __FILE__;
     data.module = m;
@@ -290,6 +342,7 @@ int pa__init(pa_module *m) {
 
     u->source->parent.process_msg = source_process_msg;
     u->source->userdata = u;
+    u->source->get_formats = source_get_formats;
 
     pa_source_set_asyncmsgq(u->source, u->thread_mq.inq);
     pa_source_set_rtpoll(u->source, u->rtpoll);
@@ -356,6 +409,8 @@ void pa__done(pa_module *m) {
     if (u->rtpoll_item)
         pa_rtpoll_item_free(u->rtpoll_item);
 
+    pa_idxset_free(u->formats, (pa_free_cb_t) pa_format_info_free);
+
     if (u->rtpoll)
         pa_rtpoll_free(u->rtpoll);
 
diff --git a/src/modules/module-role-exclusive.c b/src/modules/module-role-exclusive.c
new file mode 100644
index 0000000..bd8b5d8
--- /dev/null
+++ b/src/modules/module-role-exclusive.c
@@ -0,0 +1,252 @@
+/*
+ * Copyright (c) 2018, The Linux Foundation. All rights reserved.
+ *
+ * This library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version
+ * 2.1 and only version 2.1 as published by the Free Software Foundation
+ *
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301  USA
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <pulse/xmalloc.h>
+#include <pulse/volume.h>
+
+#include <pulsecore/macro.h>
+#include <pulsecore/core.h>
+
+#include <pulsecore/hook-list.h>
+#include <pulsecore/core.h>
+#include <pulsecore/core-util.h>
+#include <pulsecore/sink-input.h>
+#include <pulsecore/modargs.h>
+
+PA_MODULE_DESCRIPTION("pause and/or stops active streams with certain roles when on new stream with same role");
+PA_MODULE_VERSION(PACKAGE_VERSION);
+PA_MODULE_LOAD_ONCE(true);
+PA_MODULE_USAGE(
+        "exclusive_roles=<Comma separated list of roles which will be exclusive> "
+        "global=<Should we operate globally or only inside the same device?>");
+
+static const char* const valid_modargs[] = {
+    "exclusive_roles",
+    "global",
+    NULL
+};
+
+struct userdata {
+    pa_core *core;
+    uint32_t n_groups;
+    pa_idxset *exclusive_roles;
+    bool global;
+    pa_hashmap *inputs_states;
+    pa_hook_slot
+        *sink_input_put_slot,
+        *sink_input_state_changed_slot,
+        *sink_input_mute_changed_slot,
+        *sink_input_unlink_slot;
+};
+
+static void process_on_sink(struct userdata *u, pa_sink *s, pa_sink_input *i, const char *exclusive_role){
+    pa_sink_input *si;
+    const char *role;
+    uint32_t idx;
+
+    PA_IDXSET_FOREACH(si, s->inputs, idx) {
+        if (si == i) {
+            /* same sink input */
+            continue;
+        }
+
+        if (!(role = pa_proplist_gets(si->proplist, PA_PROP_MEDIA_ROLE)))
+            role = "no_role";
+
+        if (pa_streq(role, exclusive_role)) {
+            /* Check if the stream with active role is playing/unmuted */
+            if ((si->state == PA_SINK_INPUT_RUNNING) && !(si->muted)) {
+                pa_log_debug("There is a active stream with exclusive role %s alive", role);
+                /* Set the active stream status as mute and pause the stream */
+                pa_sink_input_set_mute(si, true, false);
+                pa_hashmap_put(u->inputs_states, si, PA_INT_TO_PTR(1));
+                pa_sink_input_send_event(si, PA_STREAM_EVENT_REQUEST_CORK, NULL);
+                return;
+            }
+        }
+    }
+}
+
+static pa_hook_result_t process(struct userdata *u, pa_sink_input *i) {
+    const char *role, *exclusive_role;
+    uint32_t role_idx, idx;
+
+    /* Check if there is a sink input of any of the exclusive types */
+    if ( !(role = pa_proplist_gets(i->proplist, PA_PROP_MEDIA_ROLE)))
+        role = "no role";
+
+    PA_IDXSET_FOREACH(exclusive_role, u->exclusive_roles, role_idx) {
+        if (pa_streq(role, exclusive_role)) {
+            pa_sink *s = i->sink;
+            pa_log_debug("The stream is with matching exclusive role %s", exclusive_role);
+
+            if (u->global) {
+                PA_IDXSET_FOREACH(s, u->core->sinks, idx)
+                    process_on_sink(u, s, i, role);
+            } else {
+                process_on_sink(u, s, i, role);
+            }
+            break;
+        }
+    }
+
+    return PA_HOOK_OK;
+}
+
+static pa_hook_result_t sink_input_put_cb(pa_core *core, pa_sink_input *i, struct userdata *u) {
+    pa_core_assert_ref(core);
+    pa_sink_input_assert_ref(i);
+
+    if (!i->sink)
+        return PA_HOOK_OK;
+
+    return process(u, i);
+}
+
+static pa_hook_result_t sink_input_state_changed_cb(pa_core *core, pa_sink_input *i, struct userdata *u) {
+    pa_core_assert_ref(core);
+    pa_sink_input_assert_ref(i);
+
+    if (i->state == PA_SINK_INPUT_CORKED) {
+        if(pa_hashmap_get(u->inputs_states, i)) {
+            pa_sink_input_set_mute(i, false, false);
+            pa_hashmap_remove(u->inputs_states, i);
+        }
+        return PA_HOOK_OK;
+    }
+
+    if (PA_SINK_INPUT_IS_LINKED(i->state) && !(i->muted))
+        return process(u, i);
+
+    return PA_HOOK_OK;
+}
+
+static pa_hook_result_t sink_input_mute_changed_cb(pa_core *core, pa_sink_input *i, struct userdata *u) {
+    pa_core_assert_ref(core);
+    pa_sink_input_assert_ref(i);
+
+    if (!(i->muted)) {
+        if(pa_hashmap_get(u->inputs_states, i)) {
+            pa_hashmap_remove(u->inputs_states, i);
+        }
+    }
+
+    if (PA_SINK_INPUT_IS_LINKED(i->state) && (i->state != PA_SINK_INPUT_CORKED) && !(i->muted))
+        return process(u, i);
+
+    return PA_HOOK_OK;
+}
+
+static pa_hook_result_t sink_input_unlink_cb(pa_core *core, pa_sink_input *i, struct userdata *u) {
+    pa_core_assert_ref(core);
+    pa_sink_input_assert_ref(i);
+
+    if(pa_hashmap_get(u->inputs_states, i)) {
+        pa_hashmap_remove(u->inputs_states, i);
+    }
+
+    return PA_HOOK_OK;
+}
+
+int pa__init(pa_module *m) {
+    pa_modargs *ma = NULL;
+    struct userdata *u;
+    const char *roles;
+    bool global = false;
+
+    pa_assert(m);
+
+    if (!(ma = pa_modargs_new(m->argument, valid_modargs))) {
+        pa_log("Failed to parse module arguments");
+        goto fail;
+    }
+
+    m->userdata = u = pa_xnew0(struct userdata, 1);
+    u->core = m->core;
+    u->exclusive_roles = pa_idxset_new(NULL, NULL);
+    u->inputs_states = pa_hashmap_new(pa_idxset_trivial_hash_func, pa_idxset_trivial_compare_func);
+
+    roles = pa_modargs_get_value(ma, "exclusive_roles", NULL);
+    if (roles) {
+        char *n = NULL;
+        const char *split_state = NULL;
+
+        while ((n = pa_split(roles, ",", &split_state))) {
+            if (n[0] != '\0')
+                pa_idxset_put(u->exclusive_roles, n, NULL);
+            else {
+                pa_log("empty excusive role");
+                pa_xfree(n);
+                goto fail;
+            }
+        }
+    } else {
+        pa_log("No excusive_roles arg provided");
+        goto fail;
+    }
+
+    if (pa_idxset_isempty(u->exclusive_roles)) {
+        pa_log_debug("no exclusive roles provided");
+        goto fail;
+    }
+    if (pa_modargs_get_value_boolean(ma, "global", &global) < 0) {
+        pa_log("Invalid boolean parameter: global");
+        goto fail;
+    }
+    u->global = global;
+
+    u->sink_input_put_slot = pa_hook_connect(&m->core->hooks[PA_CORE_HOOK_SINK_INPUT_PUT], PA_HOOK_LATE, (pa_hook_cb_t) sink_input_put_cb, u);
+    u->sink_input_state_changed_slot = pa_hook_connect(&m->core->hooks[PA_CORE_HOOK_SINK_INPUT_STATE_CHANGED], PA_HOOK_LATE, (pa_hook_cb_t) sink_input_state_changed_cb, u);
+    u->sink_input_mute_changed_slot = pa_hook_connect(&m->core->hooks[PA_CORE_HOOK_SINK_INPUT_MUTE_CHANGED], PA_HOOK_LATE, (pa_hook_cb_t) sink_input_mute_changed_cb, u);
+    u->sink_input_unlink_slot = pa_hook_connect(&m->core->hooks[PA_CORE_HOOK_SINK_INPUT_UNLINK], PA_HOOK_LATE, (pa_hook_cb_t) sink_input_unlink_cb, u);
+    pa_modargs_free(ma);
+    return 0;
+
+fail:
+    pa__done(m);
+
+    if (ma)
+        pa_modargs_free(ma);
+    return -1;
+}
+
+void pa__done(pa_module *m) {
+    struct userdata* u;
+
+    pa_assert(m);
+
+    if (!(u = m->userdata))
+        return;
+
+    pa_hashmap_free(u->inputs_states);
+    pa_idxset_free(u->exclusive_roles, pa_xfree);
+
+    if (u->sink_input_put_slot)
+        pa_hook_slot_free(u->sink_input_put_slot);
+    if (u->sink_input_state_changed_slot)
+        pa_hook_slot_free(u->sink_input_state_changed_slot);
+    if (u->sink_input_mute_changed_slot)
+        pa_hook_slot_free(u->sink_input_mute_changed_slot);
+    if (u->sink_input_unlink_slot)
+        pa_hook_slot_free(u->sink_input_unlink_slot);
+    pa_xfree(u);
+}
diff --git a/src/modules/module-role-ignore.c b/src/modules/module-role-ignore.c
new file mode 100644
index 0000000..7acfa74
--- /dev/null
+++ b/src/modules/module-role-ignore.c
@@ -0,0 +1,327 @@
+/*
+ * Copyright (c) 2018, 2020, The Linux Foundation. All rights reserved.
+ *
+ * This library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version
+ * 2.1 and only version 2.1 as published by the Free Software Foundation
+ *
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301  USA
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <pulse/xmalloc.h>
+#include <pulse/volume.h>
+
+#include <pulsecore/macro.h>
+#include <pulsecore/core.h>
+
+#include <pulsecore/hook-list.h>
+#include <pulsecore/core.h>
+#include <pulsecore/core-util.h>
+#include <pulsecore/sink-input.h>
+#include <pulsecore/modargs.h>
+
+PA_MODULE_DESCRIPTION("Mute & ignore streams with certain roles while others exist");
+PA_MODULE_VERSION(PACKAGE_VERSION);
+PA_MODULE_LOAD_ONCE(true);
+PA_MODULE_USAGE(
+        "ignore_roles=<Comma separated list of roles which will be ignored> "
+        "active_roles=<Comma separated list of active roles> "
+        "global=<Should we operate globally or only inside the same device?>");
+
+static const char* const valid_modargs[] = {
+    "ignore_roles",
+    "active_roles",
+    "global",
+    NULL
+};
+
+struct group {
+    char *name;
+    pa_idxset *active_roles;
+    pa_idxset *ignore_roles;
+};
+
+struct userdata {
+    pa_core *core;
+    uint32_t n_groups;
+    struct group **groups;
+    bool global:1;
+    pa_hook_slot
+        *sink_input_put_slot,
+        *sink_input_state_changed_slot,
+        *sink_input_mute_changed_slot;
+};
+
+static void process_on_sink(struct userdata *u, pa_sink *s, pa_sink_input *i, struct group *g){
+    pa_sink_input *si;
+    const char *role, *active_role;
+    uint32_t role_idx, idx;
+    bool ignore = false;
+
+    PA_IDXSET_FOREACH(si, s->inputs, idx) {
+        if (si == i) {
+            pa_log_debug("same sink input");
+            continue;
+        }
+
+        if (!(role = pa_proplist_gets(si->proplist, PA_PROP_MEDIA_ROLE)))
+            role = "no_role";
+
+        PA_IDXSET_FOREACH(active_role, g->active_roles, role_idx) {
+            if ((ignore = pa_streq(role, active_role))) {
+                /* Check if the stream with active role is playing/unmuted */
+                if ((si->state == PA_SINK_INPUT_RUNNING) && !(si->muted)) {
+                    pa_log_debug("There is a active stream with active role %s and alive", role);
+                    /* Set the ignore stream status as mute as there is a active stream */
+                    pa_sink_input_set_mute(i, true, false);
+                    return;
+                }
+            }
+        }
+    }
+}
+
+static pa_hook_result_t process(struct userdata *u, pa_sink_input *i) {
+    const char *role, *ignore_role;
+    uint32_t j, role_idx, idx;
+
+    /* Check if there is a sink input of any of the ignore types */
+    if ( !(role = pa_proplist_gets(i->proplist, PA_PROP_MEDIA_ROLE)))
+        role = "no role";
+
+    for (j = 0; j < u->n_groups; j++) {
+        PA_IDXSET_FOREACH(ignore_role, u->groups[j]->ignore_roles, role_idx) {
+            if (pa_streq(role, ignore_role)) {
+                struct group *g = u->groups[j];
+                pa_sink *s = i->sink;
+
+                pa_log_debug("The stream is with matching ignore role %s", ignore_role);
+                /* Check on all available sinks for the streams matching the active role */
+                if (u->global) {
+                    PA_IDXSET_FOREACH(s, u->core->sinks, idx)
+                        process_on_sink(u, s, i, g);
+                } else {
+                    process_on_sink(u, s, i, g);
+                }
+                break;
+            }
+        }
+    }
+    return PA_HOOK_OK;
+}
+
+static pa_hook_result_t sink_input_put_cb(pa_core *core, pa_sink_input *i, struct userdata *u) {
+    pa_core_assert_ref(core);
+    pa_sink_input_assert_ref(i);
+
+    if (!i->sink || i->muted)
+        return PA_HOOK_OK;
+
+    return process(u, i);
+}
+
+static pa_hook_result_t sink_input_state_changed_cb(pa_core *core, pa_sink_input *i, struct userdata *u) {
+    pa_core_assert_ref(core);
+    pa_sink_input_assert_ref(i);
+
+    if (PA_SINK_INPUT_IS_LINKED(i->state) && !(i->muted))
+        return process(u, i);
+
+    return PA_HOOK_OK;
+}
+
+static pa_hook_result_t sink_input_mute_changed_cb(pa_core *core, pa_sink_input *i, struct userdata *u) {
+    pa_core_assert_ref(core);
+    pa_sink_input_assert_ref(i);
+
+    if (PA_SINK_INPUT_IS_LINKED(i->state) && !(i->muted))
+        return process(u, i);
+
+    return PA_HOOK_OK;
+}
+
+static int parse_group_roles(const char *roles_in_group, pa_idxset *role_set) {
+    const char *split_state = NULL;
+    char *n = NULL;
+
+    while ((n = pa_split(roles_in_group, ",", &split_state))) {
+        if (n[0] != '\0')
+            pa_idxset_put(role_set, n, NULL);
+        else {
+            pa_log("empty role");
+            pa_xfree(n);
+            return -1;
+        }
+    }
+    return 0;
+}
+
+static int get_group_count(const char *roles) {
+    int grp_cnt = 0;
+    if (roles) {
+        const char *split_state = NULL;
+        char *n = NULL;
+        while ((n = pa_split(roles, "/", &split_state))) {
+            grp_cnt++;
+            pa_xfree(n);
+        }
+    }
+    return grp_cnt;
+}
+
+int pa__init(pa_module *m) {
+    pa_modargs *ma = NULL;
+    struct userdata *u;
+    const char *roles;
+    char *roles_in_group = NULL;
+    bool global = false;
+    uint32_t i = 0;
+	int group_count_ac = 0, group_count_ig = 0;
+
+    pa_assert(m);
+
+    if (!(ma = pa_modargs_new(m->argument, valid_modargs))) {
+        pa_log("Failed to parse module arguments");
+        goto fail;
+    }
+
+    m->userdata = u = pa_xnew0(struct userdata, 1);
+    u->core = m->core;
+
+    /* Parse args to groups */
+    u->n_groups = 1;
+    roles = pa_modargs_get_value(ma, "active_roles", NULL);
+    if (roles) {
+        group_count_ac = get_group_count(roles);
+    }
+
+    roles = pa_modargs_get_value(ma, "ignore_roles", NULL);
+    if (roles) {
+        group_count_ig = get_group_count(roles);
+    }
+
+    if ((group_count_ac > 1 || group_count_ig > 1) && (group_count_ac != group_count_ig)) {
+        pa_log("Invalid number of groups");
+        goto fail;
+    }
+
+    if (group_count_ig > 0)
+        u->n_groups = group_count_ig;
+
+    /* Allocate memory for the groups identified */
+    u->groups = pa_xnew0(struct group*, u->n_groups);
+
+    for (i = 0; i < u->n_groups; i++) {
+        u->groups[i] = pa_xnew0(struct group, 1);
+        u->groups[i]->active_roles = pa_idxset_new(NULL, NULL);
+        u->groups[i]->ignore_roles = pa_idxset_new(NULL, NULL);
+        u->groups[i]->name = pa_sprintf_malloc("ignore_group_%u", i);
+    }
+
+    roles = pa_modargs_get_value(ma, "active_roles", NULL);
+    if (roles) {
+        const char *group_split_state = NULL;
+        i = 0;
+
+        while ((roles_in_group = pa_split(roles, "/", &group_split_state))) {
+            if (roles_in_group[0] != '\0') {
+                if (parse_group_roles(roles_in_group, u->groups[i]->active_roles) < 0)
+                    goto fail;
+                i++;
+            } else {
+                pa_log("empty active roles");
+                goto fail;
+            }
+            pa_xfree(roles_in_group);
+        }
+    }
+
+    if (pa_idxset_isempty(u->groups[0]->active_roles)) {
+        pa_log_debug("no active role provided");
+        goto fail;
+    }
+
+    roles = pa_modargs_get_value(ma, "ignore_roles", NULL);
+    if (roles) {
+        const char *group_split_state = NULL;
+        i = 0;
+
+        while ((roles_in_group = pa_split(roles, "/", &group_split_state))) {
+            if (roles_in_group[0] != '\0') {
+                if (parse_group_roles(roles_in_group, u->groups[i]->ignore_roles) < 0)
+                    goto fail;
+                i++;
+            } else {
+                pa_log("empty ignore roles");
+                goto fail;
+            }
+            pa_xfree(roles_in_group);
+        }
+    }
+
+    if (pa_idxset_isempty(u->groups[0]->ignore_roles)) {
+        pa_log_debug("no ignore roles provided");
+        goto fail;
+    }
+
+    if (pa_modargs_get_value_boolean(ma, "global", &global) < 0) {
+        pa_log("Invalid boolean parameter: global");
+        goto fail;
+    }
+    u->global = global;
+
+    u->sink_input_put_slot = pa_hook_connect(&m->core->hooks[PA_CORE_HOOK_SINK_INPUT_PUT], PA_HOOK_LATE, (pa_hook_cb_t) sink_input_put_cb, u);
+    u->sink_input_state_changed_slot = pa_hook_connect(&m->core->hooks[PA_CORE_HOOK_SINK_INPUT_STATE_CHANGED], PA_HOOK_LATE, (pa_hook_cb_t) sink_input_state_changed_cb, u);
+    u->sink_input_mute_changed_slot = pa_hook_connect(&m->core->hooks[PA_CORE_HOOK_SINK_INPUT_MUTE_CHANGED], PA_HOOK_LATE, (pa_hook_cb_t) sink_input_mute_changed_cb, u);
+    pa_modargs_free(ma);
+    return 0;
+
+fail:
+    pa__done(m);
+    if (ma)
+        pa_modargs_free(ma);
+    if (roles_in_group)
+        pa_xfree(roles_in_group);
+
+    return -1;
+}
+
+void pa__done(pa_module *m) {
+    struct userdata* u;
+
+    pa_assert(m);
+
+    if (!(u = m->userdata))
+        return;
+
+    if (u->groups) {
+        uint32_t j;
+        for (j = 0; j < u->n_groups; j++) {
+            pa_idxset_free(u->groups[j]->active_roles, pa_xfree);
+            pa_idxset_free(u->groups[j]->ignore_roles, pa_xfree);
+            pa_xfree(u->groups[j]->name);
+            pa_xfree(u->groups[j]);
+        }
+        pa_xfree(u->groups);
+    }
+
+    if (u->sink_input_put_slot)
+        pa_hook_slot_free(u->sink_input_put_slot);
+    if (u->sink_input_state_changed_slot)
+        pa_hook_slot_free(u->sink_input_state_changed_slot);
+    if (u->sink_input_mute_changed_slot)
+        pa_hook_slot_free(u->sink_input_mute_changed_slot);
+    pa_xfree(u);
+}
diff --git a/src/modules/module-switch-on-port-available.c b/src/modules/module-switch-on-port-available.c
index de9c870..41442de 100644
--- a/src/modules/module-switch-on-port-available.c
+++ b/src/modules/module-switch-on-port-available.c
@@ -238,6 +238,64 @@ static struct port_pointers find_port_pointers(pa_device_port *port) {
     return pp;
 }
 
+static void propagate_source_port_changes(pa_device_port *selected_port) {
+    uint32_t idx = 0;
+    pa_source *source = NULL;
+    pa_device_port *port = NULL;
+    void *state;
+    bool exists = false;
+
+    pa_log_debug("propagate_source_port_changes selected_port %s", selected_port->name);
+
+    // Update the port on the available sources that belong
+    // to a particular card
+    PA_IDXSET_FOREACH(source, selected_port->card->sources, idx) {
+        pa_log_debug("propagate_source_port_changes source %s", source->name);
+        exists = false;
+        PA_HASHMAP_FOREACH(port, source->ports, state) {
+            // Check if the selected port exists on the source
+            pa_log_debug("propagate_source_port_changes source %s port %s", source->name, port->name);
+            if (port->name == selected_port->name &&
+                port->direction == selected_port->direction) {
+                    exists = true;
+                    break;
+                }
+        }
+        if (exists) {
+            pa_source_set_port(source, selected_port->name, false);
+        }
+    }
+}
+
+static void propagate_sink_port_changes(pa_device_port *selected_port) {
+    uint32_t idx = 0;
+    pa_sink *sink = NULL;
+    pa_device_port *port = NULL;
+    void *state;
+    bool exists = false;
+
+    pa_log_debug("propagate_sink_port_changes selected_port %s", selected_port->name);
+
+    // Update the port on the available sinks that belong
+    // to a particular card
+    PA_IDXSET_FOREACH(sink, selected_port->card->sinks, idx) {
+        pa_log_debug("propagate_sink_port_changes sink %s", sink->name);
+        exists = false;
+        PA_HASHMAP_FOREACH(port, sink->ports, state) {
+            // Check if the selected port exists on the sink
+            pa_log_debug("propagate_sink_port_changes sink %s port %s", sink->name, port->name);
+            if (port->name == selected_port->name &&
+                port->direction == selected_port->direction) {
+                    exists = true;
+                    break;
+                }
+        }
+        if (exists) {
+            pa_sink_set_port(sink, selected_port->name, false);
+        }
+    }
+}
+
 /* Switches to a port, switching profiles if necessary or preferred */
 static void switch_to_port(pa_device_port *port, struct port_pointers pp) {
     if (pp.is_port_active)
@@ -254,10 +312,12 @@ static void switch_to_port(pa_device_port *port, struct port_pointers pp) {
             pp = find_port_pointers(port);
     }
 
-    if (pp.source)
-        pa_source_set_port(pp.source, port->name, false);
-    if (pp.sink)
-        pa_sink_set_port(pp.sink, port->name, false);
+    if (pp.source) {
+        propagate_source_port_changes(port);
+    }
+    if (pp.sink) {
+        propagate_sink_port_changes(port);
+    }
 }
 
 /* Switches away from a port, switching profiles if necessary or preferred */
diff --git a/src/pulse/channelmap.c b/src/pulse/channelmap.c
index 6308ab5..db36746 100644
--- a/src/pulse/channelmap.c
+++ b/src/pulse/channelmap.c
@@ -214,6 +214,27 @@ pa_channel_map* pa_channel_map_init_auto(pa_channel_map *m, unsigned channels, p
                     m->map[0] = PA_CHANNEL_POSITION_MONO;
                     return m;
 
+                case 8:
+                    m->map[0] = PA_CHANNEL_POSITION_FRONT_LEFT;
+                    m->map[1] = PA_CHANNEL_POSITION_FRONT_RIGHT;
+                    m->map[2] = PA_CHANNEL_POSITION_FRONT_CENTER;
+                    m->map[3] = PA_CHANNEL_POSITION_LFE;
+                    m->map[4] = PA_CHANNEL_POSITION_SIDE_LEFT;
+                    m->map[5] = PA_CHANNEL_POSITION_SIDE_RIGHT;
+                    m->map[6] = PA_CHANNEL_POSITION_REAR_LEFT;
+                    m->map[7] = PA_CHANNEL_POSITION_REAR_RIGHT;
+                    return m;
+
+                case 7:
+                    m->map[0] = PA_CHANNEL_POSITION_FRONT_LEFT;
+                    m->map[1] = PA_CHANNEL_POSITION_FRONT_RIGHT;
+                    m->map[2] = PA_CHANNEL_POSITION_FRONT_CENTER;
+                    m->map[3] = PA_CHANNEL_POSITION_SIDE_LEFT;
+                    m->map[4] = PA_CHANNEL_POSITION_SIDE_RIGHT;
+                    m->map[5] = PA_CHANNEL_POSITION_REAR_LEFT;
+                    m->map[6] = PA_CHANNEL_POSITION_REAR_RIGHT;
+                    return m;
+
                 case 6:
                     m->map[0] = PA_CHANNEL_POSITION_FRONT_LEFT;
                     m->map[1] = PA_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER;
diff --git a/src/pulse/def.h b/src/pulse/def.h
index 4097bd8..a400ffc 100644
--- a/src/pulse/def.h
+++ b/src/pulse/def.h
@@ -694,6 +694,9 @@ typedef struct pa_timing_info {
      * playback streams and record streams connected to a monitor
      * source. */
 
+    pa_usec_t sink_sess_usec;
+    /** Value of the current sink session time. */
+
     pa_usec_t source_usec;
     /**< Time in usecs a sample takes from being recorded to being
      * delivered to the application. Only for record streams. */
diff --git a/src/pulse/format.c b/src/pulse/format.c
index 00bae2d..39180b8 100644
--- a/src/pulse/format.c
+++ b/src/pulse/format.c
@@ -49,6 +49,13 @@ static const char* const _encoding_str_table[]= {
     [PA_ENCODING_MPEG2_AAC_IEC61937] = "mpeg2-aac-iec61937",
     [PA_ENCODING_TRUEHD_IEC61937] = "truehd-iec61937",
     [PA_ENCODING_DTSHD_IEC61937] = "dtshd-iec61937",
+    [PA_ENCODING_UNKNOWN_IEC61937] = "unknown-iec61937",
+    [PA_ENCODING_UNKNOWN_4X_IEC61937] = "unknown-4x-iec61937",
+    [PA_ENCODING_UNKNOWN_HBR_IEC61937] = "unknown-hbr-iec61937",
+    [PA_ENCODING_MAT_IEC61937] = "mat-iec61937",
+    [PA_ENCODING_MPEG] = "mpeg",
+    [PA_ENCODING_AAC] = "aac",
+    [PA_ENCODING_DSD] = "dsd",
     [PA_ENCODING_ANY] = "any",
 };
 
@@ -110,6 +117,47 @@ int pa_format_info_is_pcm(const pa_format_info *f) {
     return f->encoding == PA_ENCODING_PCM;
 }
 
+int pa_format_info_is_passthrough(const pa_format_info *f) {
+    switch (f->encoding) {
+        case PA_ENCODING_AC3_IEC61937:
+        case PA_ENCODING_EAC3_IEC61937:
+        case PA_ENCODING_MPEG_IEC61937:
+        case PA_ENCODING_DTS_IEC61937:
+        case PA_ENCODING_MPEG2_AAC_IEC61937:
+        case PA_ENCODING_TRUEHD_IEC61937:
+        case PA_ENCODING_UNKNOWN_IEC61937:
+        case PA_ENCODING_UNKNOWN_4X_IEC61937:
+        case PA_ENCODING_UNKNOWN_HBR_IEC61937:
+        case PA_ENCODING_MAT_IEC61937:
+            return true;
+
+        default:
+            return false;
+    }
+}
+
+int pa_format_info_is_compressed(const pa_format_info *f) {
+    switch (f->encoding) {
+        case PA_ENCODING_MPEG:
+        case PA_ENCODING_AAC:
+        case PA_ENCODING_DSD:
+            return true;
+
+        default:
+            return false;
+    }
+}
+
+int pa_format_info_is_compressed_capture(const pa_format_info *f) {
+        switch (f->encoding) {
+        case PA_ENCODING_DSD:
+            return true;
+
+        default:
+            return false;
+    }
+}
+
 char *pa_format_info_snprint(char *s, size_t l, const pa_format_info *f) {
     char *tmp;
 
diff --git a/src/pulse/format.h b/src/pulse/format.h
index 5f97929..4c4d776 100644
--- a/src/pulse/format.h
+++ b/src/pulse/format.h
@@ -62,10 +62,33 @@ typedef enum pa_encoding {
     PA_ENCODING_DTSHD_IEC61937,
     /**< DTS-HD Master Audio encapsulated in IEC 61937 header/padding. \since 13.0 */
 
+    PA_ENCODING_UNKNOWN_IEC61937,
+    /**< Data with an unknown encoding in IEC 61937 header/padding. Required device rate is assumed to be same as the media
+     * sample rate. \since 13.0 */
+
+    PA_ENCODING_UNKNOWN_4X_IEC61937,
+    /**< Data with an unknown encoding in IEC 61937 header/padding. Required device rate is assumed to be four times the media
+     * sample rate. \since 13.0 */
+
+    PA_ENCODING_UNKNOWN_HBR_IEC61937,
+    /**< High bitrate data with an unknown encoding in IEC 61937 header/padding. \since 13.0 */
+
+    PA_ENCODING_MAT_IEC61937,
+    /**< Dolby MAT data encapsulated in IEC 61937 header/padding. */
+
     /* Remeber to update
      * https://www.freedesktop.org/wiki/Software/PulseAudio/Documentation/User/SupportedAudioFormats/
      * when adding new encodings! */
 
+    PA_ENCODING_MPEG,
+    /**< MPEG-1 or MPEG-2 (Part 3, not AAC) data. \since: FIXME */
+
+    PA_ENCODING_AAC,
+    /**< MPEG-2 or MPEG-4 AAC data. \since: FIXME */
+
+    PA_ENCODING_DSD,
+    /**< DSD data. \since: FIXME */
+
     PA_ENCODING_MAX,
     /**< Valid encoding types must be less than this value */
 
@@ -83,6 +106,9 @@ typedef enum pa_encoding {
 #define PA_ENCODING_MPEG2_AAC_IEC61937 PA_ENCODING_MPEG2_AAC_IEC61937
 #define PA_ENCODING_TRUEHD_IEC61937 PA_ENCODING_TRUEHD_IEC61937
 #define PA_ENCODING_DTSHD_IEC61937 PA_ENCODING_DTSHD_IEC61937
+#define PA_ENCODING_MPEG PA_ENCODING_MPEG
+#define PA_ENCODING_AAC PA_ENCODING_AAC
+#define PA_ENCODING_DSD PA_ENCODING_DSD
 #define PA_ENCODING_MAX PA_ENCODING_MAX
 #define PA_ENCODING_INVALID PA_ENCODING_INVALID
 /** \endcond */
@@ -120,6 +146,23 @@ int pa_format_info_valid(const pa_format_info *f);
  * (i.e.\ uncompressed data) format. \since 1.0 */
 int pa_format_info_is_pcm(const pa_format_info *f);
 
+/** Returns non-zero when the format info structure represents a compressed
+ * format which can be transmitted as a PCM-equivalent format. This primarily
+ * applies to IEC61937-encapsulated formats. \since FIXME */
+int pa_format_info_is_passthrough(const pa_format_info *f);
+
+/** Returns non-zero when the format info structure represents a compressed
+ * format which cannot be transmitted as a PCM-equivalent format. This applies
+ * to most compressed data except when encapsulated in the IEC61937 format.
+ * \since FIXME. */
+int pa_format_info_is_compressed(const pa_format_info *f);
+
+/** Returns non-zero when the format info structure represents a compressed
+ * format which cannot be transmitted as a PCM-equivalent format. This applies
+ * to most compressed data except when encapsulated in the IEC61937 format.
+ * \since FIXME. */
+int pa_format_info_is_compressed_capture(const pa_format_info *f);
+
 /** Returns non-zero if the format represented by \a first is a subset of
  * the format represented by \a second. This means that \a second must
  * have all the fields that \a first does, but the reverse need not
diff --git a/src/pulse/map-file b/src/pulse/map-file
index 3df03cd..99eb1f1 100644
--- a/src/pulse/map-file
+++ b/src/pulse/map-file
@@ -190,6 +190,8 @@ pa_format_info_get_prop_type;
 pa_format_info_get_rate;
 pa_format_info_get_sample_format;
 pa_format_info_is_compatible;
+pa_format_info_is_passthrough;
+pa_format_info_is_compressed;
 pa_format_info_is_pcm;
 pa_format_info_new;
 pa_format_info_set_channel_map;
diff --git a/src/pulse/meson.build b/src/pulse/meson.build
index c2128e0..941f8c3 100644
--- a/src/pulse/meson.build
+++ b/src/pulse/meson.build
@@ -92,7 +92,7 @@ libpulse_dep = declare_dependency(link_with: libpulse)
 
 install_headers(
   libpulse_headers, 'simple.h',
-  subdir : 'pulse'
+  install_dir : join_paths(includedir, 'pulse')
 )
 
 libpulse_simple = shared_library('pulse-simple',
diff --git a/src/pulse/stream.c b/src/pulse/stream.c
index f0c8034..ff58029 100644
--- a/src/pulse/stream.c
+++ b/src/pulse/stream.c
@@ -1742,6 +1742,13 @@ static pa_usec_t calc_time(const pa_stream *s, bool ignore_transport) {
     pa_assert(s->direction != PA_STREAM_PLAYBACK || !s->timing_info.read_index_corrupt);
     pa_assert(s->direction != PA_STREAM_RECORD || !s->timing_info.write_index_corrupt);
 
+    /* Get a time value (rather than bytes) for compressed streams */
+    if (s->format && pa_format_info_is_compressed(s->format)) {
+        if ((usec = s->timing_info.sink_sess_usec) > 0) {
+            goto finish;
+        }
+    }
+
     if (s->direction == PA_STREAM_PLAYBACK) {
         /* The last byte that was written into the output device
          * had this time value associated */
@@ -1789,6 +1796,7 @@ static pa_usec_t calc_time(const pa_stream *s, bool ignore_transport) {
         }
     }
 
+finish:
     return usec;
 }
 
@@ -1819,6 +1827,7 @@ static void stream_get_timing_info_callback(pa_pdispatch *pd, uint32_t command,
     } else {
 
         if (pa_tagstruct_get_usec(t, &i->sink_usec) < 0 ||
+            pa_tagstruct_get_usec(t, &i->sink_sess_usec) < 0 ||
             pa_tagstruct_get_usec(t, &i->source_usec) < 0 ||
             pa_tagstruct_get_boolean(t, &playing) < 0 ||
             pa_tagstruct_get_timeval(t, &local) < 0 ||
diff --git a/src/pulsecore/core-format.c b/src/pulsecore/core-format.c
index 1a21864..7d3b103 100644
--- a/src/pulsecore/core-format.c
+++ b/src/pulsecore/core-format.c
@@ -136,7 +136,23 @@ int pa_format_info_to_sample_spec_fake(const pa_format_info *f, pa_sample_spec *
     /* Note: When we add support for non-IEC61937 encapsulated compressed
      * formats, this function should return a non-zero values for these. */
 
-    ss->format = PA_SAMPLE_S16LE;
+    switch (f->encoding) {
+        case PA_ENCODING_PCM:
+            return -PA_ERR_INVALID;
+
+        case PA_ENCODING_MPEG:
+        case PA_ENCODING_AAC:
+        case PA_ENCODING_DSD:
+            /* Fake a frame size of 1 byte for compressed data */
+            ss->format = PA_SAMPLE_U8;
+            break;
+
+        default:
+            /* Passthrough format */
+            ss->format = PA_SAMPLE_S16LE;
+            break;
+    }
+
     if ((f->encoding == PA_ENCODING_TRUEHD_IEC61937) ||
         (f->encoding == PA_ENCODING_DTSHD_IEC61937)) {
         ss->channels = 8;
@@ -148,6 +164,13 @@ int pa_format_info_to_sample_spec_fake(const pa_format_info *f, pa_sample_spec *
              * sample spec's channel count. */
             pa_channel_map_init_auto(map, 8, PA_CHANNEL_MAP_ALSA);
         }
+    } else if (f->encoding == PA_ENCODING_MPEG ||
+               f->encoding == PA_ENCODING_AAC ||
+               f->encoding == PA_ENCODING_DSD) {
+        /* Fake a frame size of 1 byte for compressed data */
+        ss->channels = 1;
+        if (map)
+            pa_channel_map_init_mono(map);
     } else {
         ss->channels = 2;
         if (map)
diff --git a/src/pulsecore/device-port.c b/src/pulsecore/device-port.c
index 4f9235e..3a4c906 100644
--- a/src/pulsecore/device-port.c
+++ b/src/pulsecore/device-port.c
@@ -112,6 +112,11 @@ void pa_device_port_set_available(pa_device_port *p, pa_available_t status) {
 
         pa_subscription_post(p->core, PA_SUBSCRIPTION_EVENT_CARD|PA_SUBSCRIPTION_EVENT_CHANGE, p->card->index);
 
+        /* This may cause the sink and source pointers to become invalid, if
+         * the availability change causes the card profile to get switched. If
+         * you add code after this line, remember to take that into account. */
+        pa_hook_fire(&p->core->hooks[PA_CORE_HOOK_PORT_AVAILABLE_CHANGED], p);
+
         sink = pa_device_port_get_sink(p);
         source = pa_device_port_get_source(p);
         if (sink)
@@ -144,11 +149,6 @@ void pa_device_port_set_available(pa_device_port *p, pa_available_t status) {
                     pa_core_move_streams_to_newly_available_preferred_source(p->core, source);
             }
         }
-
-        /* This may cause the sink and source pointers to become invalid, if
-         * the availability change causes the card profile to get switched. If
-         * you add code after this line, remember to take that into account. */
-        pa_hook_fire(&p->core->hooks[PA_CORE_HOOK_PORT_AVAILABLE_CHANGED], p);
     }
 }
 
diff --git a/src/pulsecore/memchunk.h b/src/pulsecore/memchunk.h
index 2b19712..92cc885 100644
--- a/src/pulsecore/memchunk.h
+++ b/src/pulsecore/memchunk.h
@@ -31,6 +31,7 @@ typedef struct pa_memchunk pa_memchunk;
 struct pa_memchunk {
     pa_memblock *memblock;
     size_t index, length;
+    uint64_t timestamp, duration;
 };
 
 /* Make a memchunk writable, i.e. make sure that the caller may have
diff --git a/src/pulsecore/meson.build b/src/pulsecore/meson.build
index d7f9ef2..984725d 100644
--- a/src/pulsecore/meson.build
+++ b/src/pulsecore/meson.build
@@ -172,45 +172,18 @@ endif
 
 # FIXME: SIMD support (ORC)
 simd = import('unstable-simd')
-simd_variants = [
-  { 'mmx' : ['remap_mmx.c', 'svolume_mmx.c'] },
-  { 'sse' : ['remap_sse.c', 'sconv_sse.c', 'svolume_sse.c'] },
-  { 'neon' : ['remap_neon.c', 'sconv_neon.c', 'mix_neon.c'] },
-]
-
-libpulsecore_simd_lib = []
-
-foreach simd_kwargs : simd_variants
-
-  if host_machine.cpu_family() == 'arm' and 'neon' in simd_kwargs
-    if not cc.compiles('''
-        #include <arm_neon.h>
-        int main() {
-            return sizeof(uint8x8_t) + sizeof(int32x4_t) + sizeof(float32x4_t);
-        }
-        ''', name : 'neon code')
-      continue
-    endif
-  endif
-
-  libpulsecore_simd = simd.check('libpulsecore_simd',
-    kwargs : simd_kwargs,
-    c_args : [pa_c_args],
-    include_directories : [configinc, topinc],
-    implicit_include_directories : false,
-    compiler : cc)
+libpulsecore_simd = simd.check('libpulsecore_simd',
+  mmx : ['remap_mmx.c', 'svolume_mmx.c'],
+  sse : ['remap_sse.c', 'sconv_sse.c', 'svolume_sse.c'],
+  neon : ['remap_neon.c', 'sconv_neon.c', 'mix_neon.c'],
+  c_args : [pa_c_args],
+  include_directories : [configinc, topinc],
+  implicit_include_directories : false,
+  compiler : cc)
+libpulsecore_simd_lib = libpulsecore_simd[0]
+cdata.merge_from(libpulsecore_simd[1])
 
-  libpulsecore_simd_lib += libpulsecore_simd[0]
-  cdata.merge_from(libpulsecore_simd[1])
-endforeach
 
-if host_machine.system() == 'windows'
-  libpulsecore_sources += ['mutex-win32.c',
-    'poll-win32.c',
-    'semaphore-win32.c',
-    'thread-win32.c',
-  ]
-endif
 
 libpulsecore = shared_library('pulsecore-' + pa_version_major_minor,
   libpulsecore_sources, libpulsecore_headers,
diff --git a/src/pulsecore/protocol-native.c b/src/pulsecore/protocol-native.c
index f8dad57..e3f2106 100644
--- a/src/pulsecore/protocol-native.c
+++ b/src/pulsecore/protocol-native.c
@@ -145,6 +145,7 @@ typedef struct playback_stream {
     int64_t read_index, write_index;
     size_t render_memblockq_length;
     pa_usec_t current_sink_latency;
+    uint64_t current_sink_sess_time;
     uint64_t playing_for, underrun_for;
 } playback_stream;
 
@@ -248,6 +249,7 @@ static void sink_input_process_rewind_cb(pa_sink_input *i, size_t nbytes);
 static void sink_input_update_max_rewind_cb(pa_sink_input *i, size_t nbytes);
 static void sink_input_update_max_request_cb(pa_sink_input *i, size_t nbytes);
 static void sink_input_send_event_cb(pa_sink_input *i, const char *event, pa_proplist *pl);
+static void sink_input_drain_complete_cb(pa_sink_input *i);
 
 static void native_connection_send_memblock(pa_native_connection *c);
 static void playback_stream_request_bytes(struct playback_stream*s);
@@ -1064,6 +1066,7 @@ static playback_stream* playback_stream_new(
     s->sink_input->moving = sink_input_moving_cb;
     s->sink_input->suspend = sink_input_suspend_cb;
     s->sink_input->send_event = sink_input_send_event_cb;
+    s->sink_input->drain_complete = sink_input_drain_complete_cb;
     s->sink_input->userdata = s;
 
     start_index = ssync ? pa_memblockq_get_read_index(ssync->memblockq) : 0;
@@ -1404,7 +1407,35 @@ static int sink_input_process_msg(pa_msgobject *o, int code, void *userdata, int
                 handle_seek(ssync, windex);
             }
 
-            if (code == SINK_INPUT_MESSAGE_DRAIN) {
+            /* For compressed streams, we need to send the flush all the way to
+             * the sink so that it can drop any buffered data if possible. */
+            if (pa_sink_input_is_compressed(i)) {
+                switch (code) {
+                    case SINK_INPUT_MESSAGE_FLUSH:
+                        if (pa_sink_flush(i->sink) < 0)
+                            pa_log_warn("Unable to flush sink");
+                        break;
+
+                    case SINK_INPUT_MESSAGE_DRAIN:
+                        s->drain_tag = PA_PTR_TO_UINT(userdata);
+
+                        if (!pa_memblockq_is_readable(s->memblockq)) {
+                            if (pa_sink_drain(i->sink) < 0) {
+                                pa_log_warn("Unable to drain sink");
+                                /* We're not going to get an ack from the sink,
+                                 * tell the clientto not wait */
+                                pa_asyncmsgq_post(pa_thread_mq_get()->outq, PA_MSGOBJECT(s), PLAYBACK_STREAM_MESSAGE_DRAIN_ACK, userdata, 0, NULL, NULL);
+                            }
+                        } else {
+                            /* Schedule the drain for when the buffer runs empty */
+                            s->drain_request = true;
+                        }
+
+                    default:
+                        break;
+                }
+            } else if (code == SINK_INPUT_MESSAGE_DRAIN) {
+                /* Handle drains for non-compressed streams */
                 if (!pa_memblockq_is_readable(s->memblockq))
                     pa_asyncmsgq_post(pa_thread_mq_get()->outq, PA_MSGOBJECT(s), PLAYBACK_STREAM_MESSAGE_DRAIN_ACK, userdata, 0, NULL, NULL);
                 else {
@@ -1422,6 +1453,7 @@ static int sink_input_process_msg(pa_msgobject *o, int code, void *userdata, int
             s->write_index = pa_memblockq_get_write_index(s->memblockq);
             s->render_memblockq_length = pa_memblockq_get_length(s->sink_input->thread_info.render_memblockq);
             s->current_sink_latency = pa_sink_get_latency_within_thread(s->sink_input->sink, false);
+            s->current_sink_sess_time = s->sink_input->sink->sess_time;
             s->underrun_for = s->sink_input->thread_info.underrun_for;
             s->playing_for = s->sink_input->thread_info.playing_for;
 
@@ -1476,12 +1508,26 @@ static bool handle_input_underrun(playback_stream *s, bool force) {
         pa_log_debug("%s %s of '%s'", force ? "Actual" : "Implicit",
             s->drain_request ? "drain" : "underrun", pa_strnull(pa_proplist_gets(s->sink_input->proplist, PA_PROP_MEDIA_NAME)));
 
-    send_drain = s->drain_request && (force || pa_sink_input_safe_to_remove(s->sink_input));
+    send_drain = s->drain_request && (force || pa_sink_input_safe_to_remove(s->sink_input) || pa_sink_input_is_compressed(s->sink_input));
 
     if (send_drain) {
-         s->drain_request = false;
-         pa_asyncmsgq_post(pa_thread_mq_get()->outq, PA_MSGOBJECT(s), PLAYBACK_STREAM_MESSAGE_DRAIN_ACK, PA_UINT_TO_PTR(s->drain_tag), 0, NULL, NULL);
-         pa_log_debug("Drain acknowledged of '%s'", pa_strnull(pa_proplist_gets(s->sink_input->proplist, PA_PROP_MEDIA_NAME)));
+         if (!pa_sink_input_is_compressed(s->sink_input)) {
+             s->drain_request = false;
+             pa_asyncmsgq_post(pa_thread_mq_get()->outq, PA_MSGOBJECT(s), PLAYBACK_STREAM_MESSAGE_DRAIN_ACK, PA_UINT_TO_PTR(s->drain_tag), 0, NULL, NULL);
+             pa_log_debug("Drain acknowledged of '%s'", pa_strnull(pa_proplist_gets(s->sink_input->proplist, PA_PROP_MEDIA_NAME)));
+         } else {
+             /* Now trigger a drain on the (compressed) sink as well */
+             if (pa_sink_drain(s->sink_input->sink) < 0) {
+                 s->drain_request = false;
+                 pa_log_warn("Unable to drain sink");
+                 /* We're not going to get an ack from the sink, tell the
+                  * client to not wait */
+                 pa_asyncmsgq_post(pa_thread_mq_get()->outq, PA_MSGOBJECT(s), PLAYBACK_STREAM_MESSAGE_DRAIN_ACK, PA_UINT_TO_PTR(s->drain_tag), 0, NULL, NULL);
+             } else {
+                 /* s->drain_request is still true, and will get cleared on
+                  * completion of the drain */
+             }
+         }
     } else if (!s->is_underrun) {
          pa_asyncmsgq_post(pa_thread_mq_get()->outq, PA_MSGOBJECT(s), PLAYBACK_STREAM_MESSAGE_UNDERFLOW, NULL, pa_memblockq_get_read_index(s->memblockq), NULL, NULL);
     }
@@ -1618,6 +1664,24 @@ static void sink_input_send_event_cb(pa_sink_input *i, const char *event, pa_pro
     pa_pstream_send_tagstruct(s->connection->pstream, t);
 }
 
+/* Called from thread context */
+static void sink_input_drain_complete_cb(pa_sink_input *i)
+{
+    playback_stream *s;
+
+    pa_sink_input_assert_ref(i);
+    s = PLAYBACK_STREAM(i->userdata);
+    playback_stream_assert_ref(s);
+
+    /* This can happen if a sink was in the middle of a drain, a sink-input
+     * went away, and a new one came in */
+    if (!s->drain_request)
+        return;
+
+    pa_asyncmsgq_post(pa_thread_mq_get()->outq, PA_MSGOBJECT(s), PLAYBACK_STREAM_MESSAGE_DRAIN_ACK, PA_UINT_TO_PTR(s->drain_tag), 0, NULL, NULL);
+    pa_log_debug("Drain acknowledged of '%s'", pa_strnull(pa_proplist_gets(s->sink_input->proplist, PA_PROP_MEDIA_NAME)));
+}
+
 /* Called from main context */
 static void sink_input_suspend_cb(pa_sink_input *i, pa_sink_state_t old_state, pa_suspend_cause_t old_suspend_cause) {
     playback_stream *s;
@@ -2898,6 +2962,7 @@ static void command_get_playback_latency(pa_pdispatch *pd, uint32_t command, uin
     pa_tagstruct_put_usec(reply,
                           s->current_sink_latency +
                           pa_bytes_to_usec(s->render_memblockq_length, &s->sink_input->sink->sample_spec));
+    pa_tagstruct_put_usec(reply, s->current_sink_sess_time);
     pa_tagstruct_put_usec(reply, 0);
     pa_tagstruct_put_boolean(reply,
                              s->playing_for > 0 &&
@@ -2942,6 +3007,7 @@ static void command_get_record_latency(pa_pdispatch *pd, uint32_t command, uint3
 
     reply = reply_new(tag);
     pa_tagstruct_put_usec(reply, s->current_monitor_latency);
+    pa_tagstruct_put_usec(reply, 0);
     pa_tagstruct_put_usec(reply,
                           s->current_source_latency +
                           pa_bytes_to_usec(s->on_the_fly_snapshot, &s->source_output->sample_spec));
diff --git a/src/pulsecore/sink-input.c b/src/pulsecore/sink-input.c
index 5e7657c..b78bb12 100644
--- a/src/pulsecore/sink-input.c
+++ b/src/pulsecore/sink-input.c
@@ -87,7 +87,7 @@ static void sink_input_free(pa_object *o);
 static void set_real_ratio(pa_sink_input *i, const pa_cvolume *v);
 
 static int check_passthrough_connection(bool passthrough, pa_sink *dest) {
-    if (pa_sink_is_passthrough(dest)) {
+    if (pa_sink_is_exclusive(dest)) {
         pa_log_warn("Sink is already connected to PASSTHROUGH input");
         return -PA_ERR_BUSY;
     }
@@ -131,10 +131,22 @@ void pa_sink_input_new_data_set_channel_map(pa_sink_input_new_data *data, const
         data->channel_map = *map;
 }
 
+bool pa_sink_input_new_data_is_pcm(pa_sink_input_new_data *data) {
+    pa_assert(data);
+
+    if (data->format && pa_format_info_is_pcm(data->format))
+        return true;
+
+    if (!data->format)
+        return true;
+
+    return false;
+}
+
 bool pa_sink_input_new_data_is_passthrough(pa_sink_input_new_data *data) {
     pa_assert(data);
 
-    if (PA_LIKELY(data->format) && PA_UNLIKELY(!pa_format_info_is_pcm(data->format)))
+    if (PA_LIKELY(data->format) && PA_UNLIKELY(pa_format_info_is_passthrough(data->format)))
         return true;
 
     if (PA_UNLIKELY(data->flags & PA_SINK_INPUT_PASSTHROUGH))
@@ -143,6 +155,15 @@ bool pa_sink_input_new_data_is_passthrough(pa_sink_input_new_data *data) {
     return false;
 }
 
+bool pa_sink_input_new_data_is_compressed(pa_sink_input_new_data *data) {
+    pa_assert(data);
+
+    if (data->format && pa_format_info_is_compressed(data->format))
+        return true;
+
+    return false;
+}
+
 void pa_sink_input_new_data_set_volume(pa_sink_input_new_data *data, const pa_cvolume *volume) {
     pa_assert(data);
     pa_assert(data->volume_writable);
@@ -373,7 +394,7 @@ int pa_sink_input_new(
 
     /* Routing is done. We have a sink and a format. */
 
-    if (data->volume_is_set && !pa_sink_input_new_data_is_passthrough(data)) {
+    if (data->volume_is_set && pa_sink_input_new_data_is_pcm(data)) {
         /* If volume is set, we need to save the original data->channel_map,
          * so that we can remap the volume from the original channel map to the
          * final channel map of the stream in case data->channel_map gets
@@ -400,7 +421,7 @@ int pa_sink_input_new(
 
     /* Don't restore (or save) stream volume for passthrough streams and
      * prevent attenuation/gain */
-    if (pa_sink_input_new_data_is_passthrough(data)) {
+    if (!pa_sink_input_new_data_is_pcm(data)) {
         data->volume_is_set = true;
         pa_cvolume_reset(&data->volume, data->sample_spec.channels);
         data->volume_is_absolute = true;
@@ -424,13 +445,22 @@ int pa_sink_input_new(
     if (!data->muted_is_set)
         data->muted = false;
 
-    if (!(data->flags & PA_SINK_INPUT_VARIABLE_RATE) &&
-        !pa_sample_spec_equal(&data->sample_spec, &data->sink->sample_spec)) {
-        /* try to change sink format and rate. This is done before the FIXATE hook since
-           module-suspend-on-idle can resume a sink */
+    if (!pa_sink_input_new_data_is_compressed(data)) {
+        if ((!(data->flags & PA_SINK_INPUT_VARIABLE_RATE) &&
+            !pa_sample_spec_equal(&data->sample_spec, &data->sink->sample_spec)) ||
+            pa_sink_input_new_data_is_passthrough(data)) {
+            /* try to change sink format and rate. This is done before the FIXATE hook since
+            module-suspend-on-idle can resume a sink */
 
-        pa_log_info("Trying to change sample spec");
-        pa_sink_reconfigure(data->sink, &data->sample_spec, pa_sink_input_new_data_is_passthrough(data));
+            pa_log_info("Trying to change sample spec");
+            pa_sink_reconfigure(data->sink, &data->sample_spec, pa_sink_input_new_data_is_passthrough(data));
+        }
+    } else {
+        /* Set the compressed format on the sink */
+        if (!pa_sink_set_format(data->sink, data->format)) {
+            pa_log_info("Could not configure sink for: %s", pa_format_info_snprint(fmt, sizeof(fmt), data->format));
+            return -PA_ERR_NOTSUPPORTED;
+        }
     }
 
     if (pa_sink_input_new_data_is_passthrough(data) &&
@@ -465,7 +495,7 @@ int pa_sink_input_new(
         !pa_channel_map_equal(&data->channel_map, &data->sink->channel_map)) {
 
         /* Note: for passthrough content we need to adjust the output rate to that of the current sink-input */
-        if (!pa_sink_input_new_data_is_passthrough(data)) /* no resampler for passthrough content */
+        if (pa_sink_input_new_data_is_pcm(data)) /* no resampler for passthrough/compressed content */
             if (!(resampler = pa_resampler_new(
                           core->mempool,
                           &data->sample_spec, &data->channel_map,
@@ -623,6 +653,7 @@ static void sink_input_set_state(pa_sink_input *i, pa_sink_input_state_t state)
 
     if (i->sink) {
         if (i->state == PA_SINK_INPUT_CORKED && state == PA_SINK_INPUT_RUNNING && pa_sink_used_by(i->sink) == 0 &&
+            !pa_sink_input_is_compressed(i) &&
             !pa_sample_spec_equal(&i->sample_spec, &i->sink->sample_spec)) {
             /* We were uncorked and the sink was not playing anything -- let's try
              * to update the sample format and rate to avoid resampling */
@@ -729,9 +760,15 @@ void pa_sink_input_unlink(pa_sink_input *i) {
     reset_callbacks(i);
 
     if (i->sink) {
-        if (PA_SINK_IS_LINKED(i->sink->state))
+        if (PA_SINK_IS_LINKED(i->sink->state)) {
             pa_sink_update_status(i->sink);
 
+            if (pa_sink_input_is_compressed(i)) {
+                if (!pa_sink_set_format(i->sink, NULL))
+                    pa_log_warn("Sink could not exit compressed mode");
+            }
+        }
+
         i->sink = NULL;
     }
 
@@ -1391,11 +1428,24 @@ static void set_real_ratio(pa_sink_input *i, const pa_cvolume *v) {
     /* We don't copy the data to the thread_info data. That's left for someone else to do */
 }
 
+/* Called from main or I/O context */
+bool pa_sink_input_is_pcm(pa_sink_input *i) {
+    pa_sink_input_assert_ref(i);
+
+    if (PA_UNLIKELY(pa_format_info_is_passthrough(i->format) || pa_format_info_is_compressed(i->format)))
+        return false;
+
+    if (PA_UNLIKELY(i->flags & PA_SINK_INPUT_PASSTHROUGH))
+        return false;
+
+    return true;
+}
+
 /* Called from main or I/O context */
 bool pa_sink_input_is_passthrough(pa_sink_input *i) {
     pa_sink_input_assert_ref(i);
 
-    if (PA_UNLIKELY(!pa_format_info_is_pcm(i->format)))
+    if (PA_UNLIKELY(pa_format_info_is_passthrough(i->format)))
         return true;
 
     if (PA_UNLIKELY(i->flags & PA_SINK_INPUT_PASSTHROUGH))
@@ -1404,6 +1454,16 @@ bool pa_sink_input_is_passthrough(pa_sink_input *i) {
     return false;
 }
 
+/* Called from main or I/O context */
+bool pa_sink_input_is_compressed(pa_sink_input *i) {
+    pa_sink_input_assert_ref(i);
+
+    if (PA_UNLIKELY(pa_format_info_is_compressed(i->format)))
+        return true;
+
+    return false;
+}
+
 /* Called from main context */
 bool pa_sink_input_is_volume_readable(pa_sink_input *i) {
     pa_sink_input_assert_ref(i);
@@ -1929,8 +1989,10 @@ int pa_sink_input_finish_move(pa_sink_input *i, pa_sink *dest, bool save) {
         return -PA_ERR_NOTSUPPORTED;
     }
 
-    if (!(i->flags & PA_SINK_INPUT_VARIABLE_RATE) &&
-        !pa_sample_spec_equal(&i->sample_spec, &dest->sample_spec)) {
+    if ((!(i->flags & PA_SINK_INPUT_VARIABLE_RATE) &&
+         !pa_sink_input_is_compressed(i) &&
+         !pa_sample_spec_equal(&i->sample_spec, &dest->sample_spec)) ||
+         pa_sink_input_is_passthrough(i)) {
         /* try to change dest sink format and rate if possible without glitches.
            module-suspend-on-idle resumes destination sink with
            SINK_INPUT_MOVE_FINISH hook */
@@ -2475,3 +2537,9 @@ void pa_sink_input_set_preferred_sink(pa_sink_input *i, pa_sink *s) {
         pa_sink_input_move_to(i, i->core->default_sink, false);
     }
 }
+
+/* Called from IO context */
+void pa_sink_input_drain_complete(pa_sink_input *i) {
+    if (i->drain_complete)
+        i->drain_complete(i);
+}
diff --git a/src/pulsecore/sink-input.h b/src/pulsecore/sink-input.h
index d3de6e3..bd53fda 100644
--- a/src/pulsecore/sink-input.h
+++ b/src/pulsecore/sink-input.h
@@ -231,6 +231,11 @@ struct pa_sink_input {
      * mute status changes. Called from main context */
     void (*mute_changed)(pa_sink_input *i); /* may be NULL */
 
+    /* If non-NULL this function is called when for a compressed
+     * stream, a drain was called and the sink has completed the
+     * drain request */
+    void (*drain_complete)(pa_sink_input *i); /* may be NULL */
+
     struct {
         pa_sink_input_state_t state;
 
@@ -328,7 +333,9 @@ typedef struct pa_sink_input_new_data {
 pa_sink_input_new_data* pa_sink_input_new_data_init(pa_sink_input_new_data *data);
 void pa_sink_input_new_data_set_sample_spec(pa_sink_input_new_data *data, const pa_sample_spec *spec);
 void pa_sink_input_new_data_set_channel_map(pa_sink_input_new_data *data, const pa_channel_map *map);
+bool pa_sink_input_new_data_is_pcm(pa_sink_input_new_data *data);
 bool pa_sink_input_new_data_is_passthrough(pa_sink_input_new_data *data);
+bool pa_sink_input_new_data_is_compressed(pa_sink_input_new_data *data);
 void pa_sink_input_new_data_set_volume(pa_sink_input_new_data *data, const pa_cvolume *volume);
 void pa_sink_input_new_data_add_volume_factor(pa_sink_input_new_data *data, const char *key, const pa_cvolume *volume_factor);
 void pa_sink_input_new_data_add_volume_factor_sink(pa_sink_input_new_data *data, const char *key, const pa_cvolume *volume_factor);
@@ -374,7 +381,9 @@ void pa_sink_input_kill(pa_sink_input*i);
 
 pa_usec_t pa_sink_input_get_latency(pa_sink_input *i, pa_usec_t *sink_latency);
 
+bool pa_sink_input_is_pcm(pa_sink_input *i);
 bool pa_sink_input_is_passthrough(pa_sink_input *i);
+bool pa_sink_input_is_compressed(pa_sink_input *i);
 bool pa_sink_input_is_volume_readable(pa_sink_input *i);
 void pa_sink_input_set_volume(pa_sink_input *i, const pa_cvolume *volume, bool save, bool absolute);
 void pa_sink_input_add_volume_factor(pa_sink_input *i, const char *key, const pa_cvolume *volume_factor);
@@ -421,6 +430,9 @@ pa_usec_t pa_sink_input_set_requested_latency_within_thread(pa_sink_input *i, pa
 bool pa_sink_input_safe_to_remove(pa_sink_input *i);
 bool pa_sink_input_process_underrun(pa_sink_input *i);
 
+/* Used by compressed sinks to signal end of drain */
+void pa_sink_input_drain_complete(pa_sink_input *i);
+
 pa_memchunk* pa_sink_input_get_silence(pa_sink_input *i, pa_memchunk *ret);
 
 /* Calls the attach() callback if it's set. The input must be in detached
diff --git a/src/pulsecore/sink.c b/src/pulsecore/sink.c
index 905e1db..76c733b 100644
--- a/src/pulsecore/sink.c
+++ b/src/pulsecore/sink.c
@@ -38,6 +38,7 @@
 #include <pulsecore/i18n.h>
 #include <pulsecore/sink-input.h>
 #include <pulsecore/namereg.h>
+#include <pulsecore/core-format.h>
 #include <pulsecore/core-util.h>
 #include <pulsecore/sample-util.h>
 #include <pulsecore/mix.h>
@@ -354,6 +355,8 @@ pa_sink* pa_sink_new(
     s->thread_info.volume_change_extra_delay = core->deferred_volume_extra_delay_usec;
     s->thread_info.port_latency_offset = s->port_latency_offset;
 
+    s->sess_time = 0;
+
     /* FIXME: This should probably be moved to pa_sink_put() */
     pa_assert_se(pa_idxset_put(core->sinks, s, &s->index) >= 0);
 
@@ -1511,9 +1514,10 @@ void pa_sink_reconfigure(pa_sink *s, pa_sample_spec *spec, bool passthrough) {
 
     } else if (avoid_resampling) {
         /* We just try to set the sink input's sample rate if it's not too low */
-        if (spec->rate >= default_rate || spec->rate >= alternate_rate)
+        if (spec->rate != default_rate || spec->rate >= alternate_rate)
             desired_spec.rate = spec->rate;
         desired_spec.format = spec->format;
+        desired_spec.channels = spec->channels;
 
     } else if (default_rate == spec->rate || alternate_rate == spec->rate) {
         /* We can directly try to use this rate */
@@ -1538,7 +1542,7 @@ void pa_sink_reconfigure(pa_sink *s, pa_sample_spec *spec, bool passthrough) {
             desired_spec.rate = default_rate;
     }
 
-    if (pa_sample_spec_equal(&desired_spec, &s->sample_spec) && passthrough == pa_sink_is_passthrough(s))
+    if (pa_sample_spec_equal(&desired_spec, &s->sample_spec) && passthrough == pa_sink_is_exclusive(s))
         return;
 
     if (!passthrough && pa_sink_used_by(s) > 0)
@@ -1662,17 +1666,17 @@ bool pa_sink_is_filter(pa_sink *s) {
 }
 
 /* Called from main context */
-bool pa_sink_is_passthrough(pa_sink *s) {
+bool pa_sink_is_exclusive(pa_sink *s) {
     pa_sink_input *alt_i;
     uint32_t idx;
 
     pa_sink_assert_ref(s);
 
-    /* one and only one PASSTHROUGH input can possibly be connected */
+    /* one and only one passthrough or compressed input can possibly be connected */
     if (pa_idxset_size(s->inputs) == 1) {
         alt_i = pa_idxset_first(s->inputs, &idx);
 
-        if (pa_sink_input_is_passthrough(alt_i))
+        if (!pa_sink_input_is_pcm(alt_i))
             return true;
     }
 
@@ -2099,13 +2103,6 @@ void pa_sink_set_volume(
     pa_assert(volume || pa_sink_flat_volume_enabled(s));
     pa_assert(!volume || volume->channels == 1 || pa_cvolume_compatible(volume, &s->sample_spec));
 
-    /* make sure we don't change the volume when a PASSTHROUGH input is connected ...
-     * ... *except* if we're being invoked to reset the volume to ensure 0 dB gain */
-    if (pa_sink_is_passthrough(s) && (!volume || !pa_cvolume_is_norm(volume))) {
-        pa_log_warn("Cannot change volume, Sink is connected to PASSTHROUGH input");
-        return;
-    }
-
     /* In case of volume sharing, the volume is set for the root sink first,
      * from which it's then propagated to the sharing sinks. */
     root_sink = pa_sink_get_master(s);
@@ -3837,6 +3834,44 @@ pa_idxset* pa_sink_get_formats(pa_sink *s) {
     return ret;
 }
 
+/* Called from the main thread */
+/* Configures the sink for this specific (compressed) format */
+bool pa_sink_set_format(pa_sink *s, pa_format_info *f) {
+    pa_channel_map old_map;
+    bool ret;
+
+    pa_assert(s);
+
+    if (!s->set_format)
+        return false;
+
+    old_map = s->channel_map;
+
+    if (f) {
+        s->saved_spec = s->sample_spec;
+        s->saved_map = s->channel_map;
+
+        pa_format_info_to_sample_spec_fake(f, &s->sample_spec, &s->channel_map);
+    } else {
+        s->sample_spec = s->saved_spec;
+        s->channel_map = s->saved_map;
+
+        /* Invalidate to make sure we don't reuse this unexpectedly */
+        pa_sample_spec_init(&s->saved_spec);
+        pa_channel_map_init(&s->saved_map);
+    }
+
+    /* Fixup volumes to be valid */
+    pa_cvolume_remap(&s->reference_volume, &old_map, &s->channel_map);
+    pa_cvolume_remap(&s->real_volume, &old_map, &s->channel_map);
+    pa_cvolume_remap(&s->soft_volume, &old_map, &s->channel_map);
+
+    /* Set the format on the sink */
+    ret = s->set_format(s, f);
+
+    return ret;
+}
+
 /* Called from the main thread */
 /* Allows an external source to set what formats a sink supports if the sink
  * permits this. The function makes a copy of the formats on success. */
@@ -4015,3 +4050,45 @@ void pa_sink_move_streams_to_default_sink(pa_core *core, pa_sink *old_sink, bool
         pa_sink_input_move_to(i, core->default_sink, false);
     }
 }
+
+/* Called from the IO thread. */
+int pa_sink_flush(pa_sink *s) {
+	pa_assert(s);
+	pa_assert_io_context();
+
+	if (s->flush)
+		return s->flush(s);
+	else
+		return -1;
+}
+
+/* Called from the IO thread. */
+int pa_sink_drain(pa_sink *s) {
+    pa_assert(s);
+    pa_assert_io_context();
+
+    if (s->drain)
+        return s->drain(s);
+    else
+        return -1;
+}
+
+/* Called from the IO thread. */
+void pa_sink_drain_complete(pa_sink *s) {
+    pa_sink_input *i;
+    uint32_t idx;
+
+    pa_assert(s);
+    pa_assert_io_context();
+
+    /* There should be only one stream in compressed mode */
+    i = pa_idxset_first(s->inputs, &idx);
+
+    /* See if the sink input is still there */
+    if (!i)
+        return;
+
+    pa_assert(pa_sink_input_is_compressed(i));
+
+    pa_sink_input_drain_complete(i);
+}
diff --git a/src/pulsecore/sink.h b/src/pulsecore/sink.h
index 87bfddd..e87b86a 100644
--- a/src/pulsecore/sink.h
+++ b/src/pulsecore/sink.h
@@ -107,7 +107,9 @@ struct pa_sink {
     bool save_muted:1;
     bool port_changing:1;
 
-    /* Saved volume state while we're in passthrough mode */
+    /* Saved state while we're in passthrough or compressed mode */
+    pa_sample_spec saved_spec;
+    pa_channel_map saved_map;
     pa_cvolume saved_volume;
     bool saved_save_volume:1;
 
@@ -266,10 +268,25 @@ struct pa_sink {
      * set). Makes a copy of the formats passed in. */
     bool (*set_formats)(pa_sink *s, pa_idxset *formats); /* may be NULL */
 
+    /* Called to inform the sink that a specific compressed stream will
+     * now be providing data to it, or to end such a configured state
+     * if the format is NULL. Must return success or failure value for
+     * whether such a configuration was successful.
+     */
+    bool (*set_format)(pa_sink *s, const pa_format_info *format); /* may be NULL */
+
     /* Called whenever device parameters need to be changed. Called from
      * main thread. */
     void (*reconfigure)(pa_sink *s, pa_sample_spec *spec, bool passthrough);
 
+    /* Called in compressed mode to flush any buffered data in the sink */
+    int (*flush)(pa_sink *s);
+
+    /* Called in compressed mode to drain any buffered data in the sink.
+     * The expectation is that this will be completed asynchronously,
+     * and when complete, pa_sink_drain_complete() must be called. */
+    int (*drain)(pa_sink *s);
+
     /* Contains copies of the above data so that the real-time worker
      * thread can work without access locking */
     struct {
@@ -328,6 +345,8 @@ struct pa_sink {
         int32_t volume_change_extra_delay;
     } thread_info;
 
+    pa_usec_t sess_time;
+
     void *userdata;
 };
 
@@ -470,9 +489,10 @@ pa_sink *pa_sink_get_master(pa_sink *s);
 
 bool pa_sink_is_filter(pa_sink *s);
 
-/* Is the sink in passthrough mode? (that is, is there a passthrough sink input
- * connected to this sink? */
-bool pa_sink_is_passthrough(pa_sink *s);
+/* Is the sink in exclusive mode? (that is, is there a passthrough or
+ * compressed sink input connected to this sink?) */
+bool pa_sink_is_exclusive(pa_sink *s);
+
 /* These should be called when a sink enters/leaves passthrough mode */
 void pa_sink_enter_passthrough(pa_sink *s);
 void pa_sink_leave_passthrough(pa_sink *s);
@@ -511,6 +531,7 @@ void pa_sink_move_all_fail(pa_queue *q);
  * https://bugs.freedesktop.org/show_bug.cgi?id=71924 */
 pa_idxset* pa_sink_get_formats(pa_sink *s);
 
+bool pa_sink_set_format(pa_sink *s, pa_format_info *format);
 bool pa_sink_set_formats(pa_sink *s, pa_idxset *formats);
 bool pa_sink_check_format(pa_sink *s, pa_format_info *f);
 pa_idxset* pa_sink_check_formats(pa_sink *s, pa_idxset *in_formats);
@@ -567,6 +588,12 @@ void pa_sink_set_reference_volume_direct(pa_sink *s, const pa_cvolume *volume);
  * current default_sink conditionally*/
 void pa_sink_move_streams_to_default_sink(pa_core *core, pa_sink *old_sink, bool default_sink_changed);
 
+int pa_sink_flush(pa_sink *s);
+
+int pa_sink_drain(pa_sink *s);
+
+void pa_sink_drain_complete(pa_sink *s);
+
 /* Verify that we called in IO context (aka 'thread context), or that
  * the sink is not yet set up, i.e. the thread not set up yet. See
  * pa_assert_io_context() in thread-mq.h for more information. */
diff --git a/src/pulsecore/source-output.c b/src/pulsecore/source-output.c
index bee9241..4ba0d4f 100644
--- a/src/pulsecore/source-output.c
+++ b/src/pulsecore/source-output.c
@@ -75,7 +75,7 @@ void pa_source_output_new_data_set_channel_map(pa_source_output_new_data *data,
 bool pa_source_output_new_data_is_passthrough(pa_source_output_new_data *data) {
     pa_assert(data);
 
-    if (PA_LIKELY(data->format) && PA_UNLIKELY(!pa_format_info_is_pcm(data->format)))
+    if (PA_LIKELY(data->format) && PA_UNLIKELY(pa_format_info_is_passthrough(data->format)))
         return true;
 
     if (PA_UNLIKELY(data->flags & PA_SOURCE_OUTPUT_PASSTHROUGH))
@@ -84,6 +84,15 @@ bool pa_source_output_new_data_is_passthrough(pa_source_output_new_data *data) {
     return false;
 }
 
+bool pa_source_output_new_data_compressed(pa_source_output_new_data *data) {
+    pa_assert(data);
+
+    if (data->format && pa_format_info_is_compressed_capture(data->format))
+        return true;
+
+    return false;
+}
+
 void pa_source_output_new_data_set_volume(pa_source_output_new_data *data, const pa_cvolume *volume) {
     pa_assert(data);
     pa_assert(data->volume_writable);
@@ -372,7 +381,13 @@ int pa_source_output_new(
     if (!data->muted_is_set)
         data->muted = false;
 
-    if (!(data->flags & PA_SOURCE_OUTPUT_VARIABLE_RATE) &&
+    if (pa_source_output_new_data_compressed(data)) {
+        // FIXME
+        // In the case of compressed offload, the format info is set to source.
+        // Source need this format information, to set the right meta-data.
+        // For example, setting of stream format information
+        pa_log_warn("TODO: Compressed capture, nothing set to actual source, missing??");
+    } else if (!(data->flags & PA_SOURCE_OUTPUT_VARIABLE_RATE) &&
         !pa_sample_spec_equal(&data->sample_spec, &data->source->sample_spec)) {
         /* try to change source format and rate. This is done before the FIXATE hook since
            module-suspend-on-idle can resume a source */
@@ -412,7 +427,8 @@ int pa_source_output_new(
         !pa_sample_spec_equal(&data->sample_spec, &data->source->sample_spec) ||
         !pa_channel_map_equal(&data->channel_map, &data->source->channel_map)) {
 
-        if (!pa_source_output_new_data_is_passthrough(data)) /* no resampler for passthrough content */
+        if (!pa_source_output_new_data_is_passthrough(data) &&
+            !pa_source_output_new_data_compressed(data)) /* no resampler for passthrough content */
             if (!(resampler = pa_resampler_new(
                         core->mempool,
                         &data->source->sample_spec, &data->source->channel_map,
@@ -1047,7 +1063,7 @@ static void set_real_ratio(pa_source_output *o, const pa_cvolume *v) {
 bool pa_source_output_is_passthrough(pa_source_output *o) {
     pa_source_output_assert_ref(o);
 
-    if (PA_UNLIKELY(!pa_format_info_is_pcm(o->format)))
+    if (PA_UNLIKELY(pa_format_info_is_passthrough(o->format)))
         return true;
 
     if (PA_UNLIKELY(o->flags & PA_SOURCE_OUTPUT_PASSTHROUGH))
diff --git a/src/pulsecore/source-output.h b/src/pulsecore/source-output.h
index 2bf5682..bcd419b 100644
--- a/src/pulsecore/source-output.h
+++ b/src/pulsecore/source-output.h
@@ -289,6 +289,7 @@ pa_source_output_new_data* pa_source_output_new_data_init(pa_source_output_new_d
 void pa_source_output_new_data_set_sample_spec(pa_source_output_new_data *data, const pa_sample_spec *spec);
 void pa_source_output_new_data_set_channel_map(pa_source_output_new_data *data, const pa_channel_map *map);
 bool pa_source_output_new_data_is_passthrough(pa_source_output_new_data *data);
+bool pa_source_output_new_data_compressed(pa_source_output_new_data *data);
 void pa_source_output_new_data_set_volume(pa_source_output_new_data *data, const pa_cvolume *volume);
 void pa_source_output_new_data_apply_volume_factor(pa_source_output_new_data *data, const pa_cvolume *volume_factor);
 void pa_source_output_new_data_apply_volume_factor_source(pa_source_output_new_data *data, const pa_cvolume *volume_factor);
diff --git a/src/pulsecore/source.c b/src/pulsecore/source.c
index 99d8dde..24e5486 100644
--- a/src/pulsecore/source.c
+++ b/src/pulsecore/source.c
@@ -1091,9 +1091,10 @@ void pa_source_reconfigure(pa_source *s, pa_sample_spec *spec, bool passthrough)
 
     } else if (avoid_resampling) {
         /* We just try to set the source output's sample rate if it's not too low */
-        if (spec->rate >= default_rate || spec->rate >= alternate_rate)
+        if (spec->rate != default_rate || spec->rate >= alternate_rate)
             desired_spec.rate = spec->rate;
         desired_spec.format = spec->format;
+        desired_spec.channels = spec->channels;
 
     } else if (default_rate == spec->rate || alternate_rate == spec->rate) {
         /* We can directly try to use this rate */
@@ -1256,8 +1257,8 @@ bool pa_source_is_passthrough(pa_source *s) {
 
     pa_source_assert_ref(s);
 
-    /* NB Currently only monitor sources support passthrough mode */
-    return (s->monitor_of && pa_sink_is_passthrough(s->monitor_of));
+    /* Check if we're a monitor source and sink is in exclusive mode */
+    return (s->monitor_of && pa_sink_is_exclusive(s->monitor_of));
 }
 
 /* Called from main context */
diff --git a/src/utils/pacat.c b/src/utils/pacat.c
index 39ccaff..f12067e 100644
--- a/src/utils/pacat.c
+++ b/src/utils/pacat.c
@@ -100,6 +100,13 @@ static bool sample_spec_set = false;
 static pa_channel_map channel_map;
 static bool channel_map_set = false;
 
+/* If the encoding is set, we assume the pa_sample_spec will not be used, and
+ * that the pa_format_info will be. */
+static pa_encoding_t encoding;
+static bool encoding_set = false;
+pa_format_info *formats[1] = { NULL, };
+static char *stream_format = "raw";
+
 static sf_count_t (*readf_function)(SNDFILE *_sndfile, void *ptr, sf_count_t frames) = NULL;
 static sf_count_t (*writef_function)(SNDFILE *_sndfile, const void *ptr, sf_count_t frames) = NULL;
 
@@ -319,7 +326,7 @@ static void stream_state_callback(pa_stream *s, void *userdata) {
 
             if (verbose) {
                 const pa_buffer_attr *a;
-                char cmt[PA_CHANNEL_MAP_SNPRINT_MAX], sst[PA_SAMPLE_SPEC_SNPRINT_MAX];
+                char cmt[PA_CHANNEL_MAP_SNPRINT_MAX], sst[PA_SAMPLE_SPEC_SNPRINT_MAX], fst[PA_FORMAT_INFO_SNPRINT_MAX];
 
                 pa_log(_("Stream successfully created."));
 
@@ -335,9 +342,14 @@ static void stream_state_callback(pa_stream *s, void *userdata) {
                     }
                 }
 
-                pa_log(_("Using sample spec '%s', channel map '%s'."),
-                        pa_sample_spec_snprint(sst, sizeof(sst), pa_stream_get_sample_spec(s)),
-                        pa_channel_map_snprint(cmt, sizeof(cmt), pa_stream_get_channel_map(s)));
+                if (!encoding_set) {
+                    pa_log(_("Using sample spec '%s', channel map '%s'."),
+                            pa_sample_spec_snprint(sst, sizeof(sst), pa_stream_get_sample_spec(s)),
+                            pa_channel_map_snprint(cmt, sizeof(cmt), pa_stream_get_channel_map(s)));
+                } else {
+                    pa_log(_("Using format '%s'."),
+                            pa_format_info_snprint(fst, sizeof(fst), pa_stream_get_format_info(s)));
+                }
 
                 pa_log(_("Connected to device %s (index: %u, suspended: %s)."),
                         pa_stream_get_device_name(s),
@@ -449,7 +461,12 @@ static void context_state_callback(pa_context *c, void *userdata) {
             if (verbose)
                 pa_log(_("Connection established.%s"), CLEAR_LINE);
 
-            if (!(stream = pa_stream_new_with_proplist(c, NULL, &sample_spec, &channel_map, proplist))) {
+            if (!encoding_set)
+                stream = pa_stream_new_with_proplist(c, NULL, &sample_spec, &channel_map, proplist);
+            else
+                stream = pa_stream_new_extended(c, NULL, formats, 1, proplist);
+
+            if (!stream) {
                 pa_log(_("pa_stream_new() failed: %s"), pa_strerror(pa_context_errno(c)));
                 goto fail;
             }
@@ -692,6 +709,8 @@ static void help(const char *argv0) {
              "      --channels=CHANNELS               The number of channels, 1 for mono, 2 for stereo\n"
              "                                        (defaults to 2)\n"
              "      --channel-map=CHANNELMAP          Channel map to use instead of the default\n"
+             "      --encoding=ENCODING               Encoding to use for non-PCM audio\n"
+             "      --stream-format=FLAG              Stream format flag to use for non-PCM audio\n"
              "      --fix-format                      Take the sample format from the sink/source the stream is\n"
              "                                        being connected to.\n"
              "      --fix-rate                        Take the sampling rate from the sink/source the stream is\n"
@@ -721,6 +740,8 @@ enum {
     ARG_SAMPLEFORMAT,
     ARG_CHANNELS,
     ARG_CHANNELMAP,
+    ARG_ENCODING,
+    ARG_STREAM_FORMAT,
     ARG_FIX_FORMAT,
     ARG_FIX_RATE,
     ARG_FIX_CHANNELS,
@@ -762,6 +783,8 @@ int main(int argc, char *argv[]) {
         {"format",       1, NULL, ARG_SAMPLEFORMAT},
         {"channels",     1, NULL, ARG_CHANNELS},
         {"channel-map",  1, NULL, ARG_CHANNELMAP},
+        {"encoding",     1, NULL, ARG_ENCODING},
+        {"stream-format", 1, NULL, ARG_STREAM_FORMAT},
         {"fix-format",   0, NULL, ARG_FIX_FORMAT},
         {"fix-rate",     0, NULL, ARG_FIX_RATE},
         {"fix-channels", 0, NULL, ARG_FIX_CHANNELS},
@@ -908,6 +931,24 @@ int main(int argc, char *argv[]) {
                 channel_map_set = true;
                 break;
 
+            case ARG_ENCODING:
+                if ((encoding = pa_encoding_from_string(optarg)) == PA_ENCODING_INVALID) {
+                    pa_log(_("Invalid encoding '%s'"), optarg);
+                    goto quit;
+                }
+
+                if (encoding == PA_ENCODING_PCM) {
+                    pa_log(_("The encoding parameter is only supported with non-PCM formats."));
+                    goto quit;
+                }
+
+                encoding_set = true;
+                break;
+
+            case ARG_STREAM_FORMAT:
+                stream_format = pa_locale_to_utf8(optarg);
+                break;
+
             case ARG_FIX_CHANNELS:
                 flags |= PA_STREAM_FIX_CHANNELS;
                 break;
@@ -1007,7 +1048,23 @@ int main(int argc, char *argv[]) {
         }
     }
 
-    if (!pa_sample_spec_valid(&sample_spec)) {
+    if (encoding_set && !raw) {
+        pa_log(_("Cannot set encoding for non-raw mode"));
+        goto quit;
+    }
+
+    if (encoding_set) {
+        formats[0] = pa_format_info_new();
+
+        formats[0]->encoding = encoding;
+        pa_format_info_set_prop_string(formats[0], "stream-format", stream_format);
+        pa_format_info_set_rate(formats[0], sample_spec.rate);
+        pa_format_info_set_channels(formats[0], sample_spec.channels);
+        if (!pa_format_info_valid(formats[0])) {
+            pa_log(_("Invalid format specification."));
+            goto quit;
+        }
+    } else if (!pa_sample_spec_valid(&sample_spec)) {
         pa_log(_("Invalid sample specification"));
         goto quit;
     }
@@ -1132,12 +1189,20 @@ int main(int argc, char *argv[]) {
     }
 
     if (verbose) {
-        char tss[PA_SAMPLE_SPEC_SNPRINT_MAX], tcm[PA_CHANNEL_MAP_SNPRINT_MAX];
+        if (!encoding_set) {
+            char tss[PA_SAMPLE_SPEC_SNPRINT_MAX], tcm[PA_CHANNEL_MAP_SNPRINT_MAX];
 
-        pa_log(_("Opening a %s stream with sample specification '%s' and channel map '%s'."),
-                mode == RECORD ? _("recording") : _("playback"),
-                pa_sample_spec_snprint(tss, sizeof(tss), &sample_spec),
-                pa_channel_map_snprint(tcm, sizeof(tcm), &channel_map));
+            pa_log(_("Opening a %s stream with sample specification '%s' and channel map '%s'."),
+                    mode == RECORD ? _("recording") : _("playback"),
+                    pa_sample_spec_snprint(tss, sizeof(tss), &sample_spec),
+                    pa_channel_map_snprint(tcm, sizeof(tcm), &channel_map));
+        } else {
+            char tsf[PA_FORMAT_INFO_SNPRINT_MAX];
+
+            pa_log(_("Opening a %s stream with format specification '%s'."),
+                    mode == RECORD ? _("recording") : _("playback"),
+                    pa_format_info_snprint(tsf, sizeof(tsf), formats[0]));
+        }
     }
 
     /* Fill in client name if none was set */
-- 
2.17.1

